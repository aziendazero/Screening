package model;

import model.common.Transfer_AppModule;

import model.commons.Parent_AppModuleImpl;

import model.transfer.Transfer_SoCnfImpexpViewImpl;
import model.transfer.Transfer_SoLogTransferViewImpl;

import oracle.jbo.ApplicationModule;
import oracle.jbo.Row;
import oracle.jbo.domain.Date;
import oracle.jbo.server.SequenceImpl;
//  ---------------------------------------------------------------------
//  ---    File generated by Oracle ADF Business Components Design Time.
//  ---    Custom code may be added to this class.
//  ---    Warning: Do not modify method signatures of generated methods.
//  ---------------------------------------------------------------------

public class Transfer_AppModuleImpl extends Parent_AppModuleImpl implements Transfer_AppModule {
    ApplicationModule am = null;
  Thread[] threads = null;

  /**
   * 
   *  This is the default constructor (do not remove)
   */
  public Transfer_AppModuleImpl()
  {
  }

  /**
     *
     *  Container's getter for Transfer_SoCnfImpexpView1
     */
    public Transfer_SoCnfImpexpViewImpl getTransfer_SoCnfImpexpView1()
  {
    return (Transfer_SoCnfImpexpViewImpl)findViewObject("Transfer_SoCnfImpexpView1");
  }

  /**
     *
     *  Container's getter for Transfer_SoLogTransferView1
     */
    public Transfer_SoLogTransferViewImpl getTransfer_SoLogTransferView1()
  {
    return (Transfer_SoLogTransferViewImpl)findViewObject("Transfer_SoLogTransferView1");
  }

  /**
   * 
   *  Sample main for debugging Business Components code using the tester.
   */
  public static void main(String[] args)
  {
    launchTester("model", "Transfer_AppModuleLocal");
  }
  

  
 /*  protected void afterConnect()
  {
   try{
    ViewObject vo=getTransfer_SoCnfImpexpView1();
    //non considero le configurazioni prive di reale trasferimento
    vo.setWhereClause("TPDIP<>'"+ConfigurationConstants.IMPEXP_LOC+"'");
    vo.executeQuery();
    
    Transfer_SoCnfImpexpViewRow row;
    
    int nThreads = vo.getRowCount();
    
    threads = new Thread[nThreads];
    
    int cThread = 0;
    
    while((row = (Transfer_SoCnfImpexpViewRow)vo.next()) != null)
    {
 
      long timeout = 60*1000;  // default 1 minuto
      Number interv = row.getIntervallo();   // espresso in secondi!
      if(interv != null)
        timeout = interv.longValue() * 1000; 


      Number oraSched = row.getOrasched();   // espresso in hhmm!
      
      Long loraSched = null;
      
      String ssched = "Schedulazione: ";

      if(oraSched != null)
      {
        loraSched = new Long(oraSched.longValue());
      
        NumberFormat formatter = new DecimalFormat("0000");
        String stime = formatter.format(loraSched);
        ssched += " ore " + stime.substring(0,2) + ":" + stime.substring(2);
      }
      else
        ssched += "immediata";
      
      am = findApplicationModule("Transfer_AppModule");
    
    //thread di import
    if(ConfigurationConstants.IMPEXP_IMP.equals(row.getImpexp())){
        log(row.getUlss(),
          row.getTpdip(),
          "Attivo thread per scarico files da " + row.getIppart()
          + " Timeout: " + timeout/1000 + " sec. " + ssched,
          row.getTpscr());

      threads[cThread]=new GetFile(am,row);
    }
    else //thread di export
    {
      log(row.getUlss(),
          row.getTpdip(),
          "Attivo thread per scarico files verso " + row.getIppart()
          + " Timeout: " + timeout/1000 + " sec. " + ssched,
          row.getTpscr());

   //   threads[cThread]=new PutFile(am,row);
    }
      
    if(threads[cThread]!=null)
        threads[cThread].start();
      
      cThread++;
      
    }
   }
   catch(Exception ex)
   {
     ex.printStackTrace();
   }
    super.afterConnect();    
  }
  

  protected void beforeDisconnect()
  {

    for (int k = 0 ; k < threads.length ; k++ ) 
    {
      // probabilmente ï¿½ meglio rimpiazzare l'istruzione destroy
      // con il set di una variabile della thread
      // che viene regolarmente controllata dalla thread stessa
      // per verificare la richiesta o meno di uscita
    
      threads[k].destroy();
    }
    

    super.beforeDisconnect();
  }  */
  
  public synchronized void  log(String azienda, String tipoDip, String msg, String tpscr)
  {
    Row newRow = getTransfer_SoLogTransferView1().createRow();
    
    // creare un sequence per l'id del log

    SequenceImpl s = new SequenceImpl("so_log_transfer_seq", am);
          
    Long next = (Long)s.getData();
   
    
    newRow.setAttribute("Idlog", next);
    newRow.setAttribute("Gruppo", tipoDip);
    newRow.setAttribute("Verso", "IMP");
    try
    {    
      newRow.setAttribute("Data", new Date(new java.sql.Timestamp(System.currentTimeMillis())));
    }
    catch(Exception e)
    {
      e.printStackTrace();
    }
    
    newRow.setAttribute("Descrizione", msg);
    newRow.setAttribute("Ulss", azienda);
    newRow.setAttribute("Tpscr", tpscr);

    
    getTransfer_SoLogTransferView1().insertRow(newRow); 
    
    getTransaction().commit();
  }

  
  public void dymmy()
  {}
}